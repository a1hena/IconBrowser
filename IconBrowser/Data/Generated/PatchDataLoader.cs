// Auto-generated by IconBrowser.DataGenerator
// Do not edit manually - run the generator to update

using System.Reflection;
using System.Text.Json;

namespace IconBrowser.Data;

public record PatchInfo(int Id, string Version, string Name, int ExVersion, string ExName, bool IsExpansion);

public static class PatchDataLoader
{
    private static PatchInfo[]? _patches;
    private static Dictionary<string, List<(int Start, int End, int PatchId)>>? _iconMappings;
    private static string[]? _expansionNames;

    public static PatchInfo[] Patches => _patches ??= LoadPatches();
    public static string[] ExpansionNames => _expansionNames ??= LoadExpansionNames();

    private static PatchInfo[] LoadPatches()
    {
        var data = LoadData();
        return data?.Patches?.Select(p => new PatchInfo(p.Id, p.Version, p.Name, p.ExVersion, p.ExName, p.IsExpansion)).ToArray() ?? [];
    }

    private static string[] LoadExpansionNames()
    {
        return Patches
            .Where(p => p.IsExpansion)
            .OrderBy(p => p.ExVersion)
            .GroupBy(p => p.ExVersion)
            .Select(g => g.First().ExName)
            .ToArray();
    }

    private static Dictionary<string, List<(int Start, int End, int PatchId)>> GetIconMappings()
    {
        if (_iconMappings != null) return _iconMappings;

        var data = LoadData();
        _iconMappings = new Dictionary<string, List<(int, int, int)>>();

        if (data?.IconMappings != null)
        {
            foreach (var (category, ranges) in data.IconMappings)
            {
                _iconMappings[category] = ranges.Select(r => (r[0], r[1], r[2])).ToList();
            }
        }

        return _iconMappings;
    }

    public static PatchInfo? GetPatch(int id) => Patches.FirstOrDefault(p => p.Id == id);
    public static PatchInfo? GetPatch(string version) => Patches.FirstOrDefault(p => p.Version == version);

    public static IEnumerable<PatchInfo> GetPatchesForExpansion(int exVersion)
        => Patches.Where(p => p.ExVersion == exVersion);

    /// <summary>Gets the patch ID for an icon in a specific category.</summary>
    public static int? GetIconPatchId(string category, int iconId)
    {
        var mappings = GetIconMappings();
        if (!mappings.TryGetValue(category, out var ranges)) return null;

        foreach (var (start, end, patchId) in ranges)
        {
            if (iconId >= start && iconId <= end)
                return patchId;
        }
        return null;
    }

    /// <summary>Gets the patch ID for an icon across all categories.</summary>
    public static int? GetIconPatchId(int iconId)
    {
        foreach (var category in Categories)
        {
            var patchId = GetIconPatchId(category, iconId);
            if (patchId.HasValue) return patchId;
        }
        return null;
    }

    /// <summary>Gets the patch version string for an icon.</summary>
    public static string? GetIconPatchVersion(int iconId)
    {
        var patchId = GetIconPatchId(iconId);
        return patchId.HasValue ? GetPatch(patchId.Value)?.Version : null;
    }

    /// <summary>Gets icon ID ranges for a specific patch and category.</summary>
    public static (int Start, int End)[] GetIconRangesForPatch(string category, int patchId)
    {
        var mappings = GetIconMappings();
        if (!mappings.TryGetValue(category, out var ranges)) return [];

        return ranges
            .Where(r => r.PatchId == patchId)
            .Select(r => (r.Start, r.End))
            .ToArray();
    }

    /// <summary>Gets all icon ID ranges for a specific patch across all categories.</summary>
    public static (string Category, int Start, int End)[] GetAllIconRangesForPatch(int patchId)
    {
        var result = new List<(string, int, int)>();
        foreach (var category in Categories)
        {
            foreach (var (start, end) in GetIconRangesForPatch(category, patchId))
            {
                result.Add((category, start, end));
            }
        }
        return result.ToArray();
    }

    public static string[] Categories => GetIconMappings().Keys.ToArray();

    private static ConsolidatedData? LoadData()
    {
        try
        {
            var assembly = Assembly.GetExecutingAssembly();
            var resourceName = assembly.GetManifestResourceNames()
                .FirstOrDefault(n => n.EndsWith("patchdata.json"));

            if (resourceName == null) return null;

            using var stream = assembly.GetManifestResourceStream(resourceName);
            if (stream == null) return null;

            return JsonSerializer.Deserialize<ConsolidatedData>(stream);
        }
        catch
        {
            return null;
        }
    }

    private class ConsolidatedData
    {
        public DateTime GeneratedAt { get; set; }
        public List<PatchInfoCompact>? Patches { get; set; }
        public Dictionary<string, List<int[]>>? IconMappings { get; set; }
    }

    private class PatchInfoCompact
    {
        public int Id { get; set; }
        public string Version { get; set; } = "";
        public string Name { get; set; } = "";
        public int ExVersion { get; set; }
        public string ExName { get; set; } = "";
        public bool IsExpansion { get; set; }
    }
}
